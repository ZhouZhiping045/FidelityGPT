__cdecl isAlterableTable(_DWORD **a1, _DWORD *a2)
{
  if ( sqlite3_strnicmp(*a2, "sqlite_", 7) && ((a2[9] & 0x1000) == 0 || !sqlite3ReadOnlyShadowTables(*a1)) )
    return 0;
  sqlite3ErrorMsg((int)a1, (int)"table %s may not be altered", *a2);
  return 1;
}
/////
__cdecl renameReloadSchema(int a1, int a2)
{
  int result;
  result = *(_DWORD *)(a1 + 8);
  if ( result )
  {
    sqlite3ChangeCookie((_DWORD **)a1, a2);
    result = sqlite3VdbeAddParseSchemaOp(*(_DWORD **)(a1 + 8), a2, 0);
    if ( a2 != 1 )
      result = sqlite3VdbeAddParseSchemaOp(*(_DWORD **)(a1 + 8), 1, 0);
  }
  return result;
}
/////
__cdecl sqlite3RenameTokenMap(int *a1, int a2, _DWORD *a3)
{
  int v3;
  int (__cdecl *v5)(int);
  if ( *((_BYTE *)a1 + (_DWORD)(&off_E00CC - 229376)) != 3 )
  {
    v5 = (int (__cdecl *)(int))sqlite3DbMallocZero(*a1, 0x10uLL);
    if ( v5 )
    {
      *(_DWORD *)v5 = a2;
      v3 = a3[1];
      *((_DWORD *)v5 + 1) = *a3;
      *((_DWORD *)v5 + 2) = v3;
      *((_DWORD *)v5 + 3) = *(int (__cdecl **)(int))((char *)&off_E0114[-229376] + (_DWORD)a1);
      *(int (__cdecl **)(int))((char *)&off_E0114[-229376] + (_DWORD)a1) = v5;
    }
  }
  return a2;
}
/////
__cdecl sqlite3RenameTokenRemap(int a1, int a2, int a3)
{
  _DWORD *result;
  _DWORD *i;
  result = *(int (__cdecl **)(int))((char *)&off_E0114[-229376] + a1);
  for ( i = result; i; i = result )
  {
    if ( a3 == *i )
    {
      result = i;
      *i = a2;
      return result;
    }
    result = (_DWORD *)i[3];
  }
  return result;
}
/////
__cdecl renameWalkWith(int *a1, int a2)
{
  int i;
  _DWORD *v4;
  int v5;
  _DWORD *s[8];
  unsigned int v7;
  v7 = __readgsdword(0x14u);
  v4 = *(_DWORD **)(a2 + 64);
  if ( v4 )
  {
    for ( i = 0; i < *v4; ++i )
    {
      v5 = v4[4 * i + 4];
      memset(s, 0, sizeof(s));
      s[0] = (_DWORD *)*a1;
      sqlite3SelectPrep(s[0], v5, (int)s);
      sqlite3WalkSelect((int)a1, v5);
      sqlite3RenameExprlistUnmap(*a1, (int *)v4[4 * i + 3]);
    }
  }
  return __readgsdword(0x14u) ^ v7;
}
/////
__cdecl renameUnmapSelectCb(int *a1, _DWORD *a2)
{
  int i;
  int j;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  v5 = *a1;
  if ( *(_DWORD *)(*a1 + 36) )
    return 2;
  if ( (a2[1] & 0x200000) != 0 )
    return 1;
  if ( a2[7] )
  {
    v6 = (_DWORD *)a2[7];
    for ( i = 0; i < *v6; ++i )
    {
      if ( v6[4 * i + 2] )
      {
        if ( (v6[4 * i + 3] & 0x300) == 0 )
          sqlite3RenameTokenRemap(v5, 0, v6[4 * i + 2]);
      }
    }
  }
  if ( a2[8] )
  {
    v7 = (_DWORD *)a2[8];
    for ( j = 0; j < *v7; ++j )
    {
      sqlite3RenameTokenRemap(v5, 0, v7[17 * j + 4]);
      if ( sqlite3WalkExpr((int)a1, (_DWORD *)v7[17 * j + 13]) )
        return 2;
      unmapColumnIdlistNames(v5, (_DWORD *)v7[17 * j + 14]);
    }
  }
  renameWalkWith(a1, (int)a2);
  return 0;
}
/////
__cdecl sqlite3RenameExprUnmap(int a1, _DWORD *a2)
{
  char v3;
  int s[7];
  unsigned int v5;
  v5 = __readgsdword(0x14u);
  v3 = *(_BYTE *)(a1 + 204);
  memset(s, 0, sizeof(s));
  s[0] = a1;
  s[1] = (int)renameUnmapExprCb;
  s[2] = (int)renameUnmapSelectCb;
  *(_BYTE *)(a1 + 204) = 3;
  sqlite3WalkExpr((int)s, a2);
  *(_BYTE *)(a1 + 204) = v3;
  return __readgsdword(0x14u) ^ v5;
}
/////
__cdecl renameTokenFind(int a1, _DWORD *a2, int a3)
{
  _DWORD *result;
  int i;
  _DWORD *v5;
  for ( i = a1 + 276; ; i = *(_DWORD *)i + 12 )
  {
    result = *(_DWORD **)i;
    if ( !*(_DWORD *)i )
      break;
    if ( a3 == **(_DWORD **)i )
    {
      v5 = *(_DWORD **)i;
      *(_DWORD *)i = *(_DWORD *)(*(_DWORD *)i + 12);
      v5[3] = *a2;
      *a2 = v5;
      result = a2;
      ++a2[1];
      return result;
    }
  }
  return result;
}
/////
__cdecl renameColumnExprCb(int *a1, int a2)
{
  _DWORD *v3;
  v3 = (_DWORD *)a1[6];
  if ( *(_BYTE *)a2 == 77 && *(__int16 *)(a2 + 32) == v3[2] && *(_DWORD *)(*a1 + 120) == v3[3]
    || *(_BYTE *)a2 == 0xA4 && *(__int16 *)(a2 + 32) == v3[2] && v3[3] == *(_DWORD *)(a2 + 44) )
  {
    renameTokenFind(*a1, v3, a2);
  }
  return 0;
}
/////
__cdecl renameColumnIdlistNames(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int i;
  int v5;
  if ( a3 )
  {
    for ( i = 0; i < a3[1]; ++i )
    {
      v5 = *(_DWORD *)(8 * i + *a3);
      if ( !sqlite3_stricmp(v5, a4) )
        renameTokenFind(a1, a2, v5);
    }
  }
}
/////
__cdecl renameWalkTrigger(int a1, int a2)
{
  int result;
  int i;
  int **v4;
  sqlite3WalkExpr(a1, *(_DWORD **)(a2 + 12));
  result = *(_DWORD *)(a2 + 28);
  for ( i = result; i; i = result )
  {
    sqlite3WalkSelect(a1, *(_DWORD *)(i + 8));
    sqlite3WalkExpr(a1, *(_DWORD **)(i + 20));
    sqlite3WalkExprList(a1, *(int **)(i + 24));
    if ( *(_DWORD *)(i + 32) )
    {
      v4 = *(int ***)(i + 32);
      sqlite3WalkExprList(a1, *v4);
      sqlite3WalkExprList(a1, v4[2]);
      sqlite3WalkExpr(a1, v4[3]);
      sqlite3WalkExpr(a1, v4[1]);
    }
    result = *(_DWORD *)(i + 40);
  }
  return result;
}
/////
__cdecl renameParseCleanup(int a1)
{
  _DWORD *v2;
  int v3;
  v2 = *(_DWORD **)a1;
  if ( *(_DWORD *)(a1 + 8) )
    sqlite3VdbeFinalize(*(_DWORD *)(a1 + 8));
  sqlite3DeleteTable(v2, *(int *)((char *)&off_E00E8 + a1 - 917504));
  while ( 1 )
  {
    v3 = *(int *)((char *)&off_E00EC + a1 - 917504);
    if ( !v3 )
      break;
    *(void **)((char *)&off_E00EC + a1 - 917504) = *(void **)(v3 + 20);
    sqlite3FreeIndex(v2, v3);
  }
  sqlite3DeleteTrigger(v2, *(int *)((char *)&off_E00F0 + a1 - 917504));
  sqlite3DbFree(v2, *(int (__cdecl **)(int, int, int, char))(a1 + 4));
  renameTokenFree(v2, *(int *)((char *)&off_E0114[-229376] + a1));
  return sqlite3ParserReset((int *)a1);
}
/////
__cdecl renameTableSelectCb(int *a1, int a2)
{
  int i;
  _DWORD *v4;
  _DWORD *v5;
  v4 = (_DWORD *)a1[6];
  v5 = *(_DWORD **)(a2 + 32);
  if ( (*(_DWORD *)(a2 + 4) & 0x200000) != 0 )
    return 1;
  if ( !v5 )
    return 2;
  for ( i = 0; i < *v5; ++i )
  {
    if ( v5[17 * i + 6] == v4[3] )
      renameTokenFind(*a1, v4, v5[17 * i + 4]);
  }
  renameWalkWith(a1, a2);
  return 0;
}
/////
__cdecl analyzeDatabase(int *a1, int a2)
{
  int **i;
  int v4;
  int v5;
  int v6;
  int v7;
  v4 = *(_DWORD *)(16 * a2 + *(_DWORD *)(*a1 + 16) + 12);
  sqlite3BeginWriteOperation((int)a1, 0, a2);
  v5 = a1[10];
  a1[10] = v5 + 3;
  openStatTable(a1, a2, v5, 0);
  v6 = a1[11] + 1;
  v7 = a1[10];
  for ( i = *(int ***)(v4 + 16); i; i = (int **)*i )
    analyzeOneTable(a1, i[2], 0, v5, v6, v7);
  return loadAnalysis(a1, a2);
}
/////
__cdecl decodeIntArray(unsigned __int8 *a1, int a2, int a3, int a4, int a5)
{
  int result;
  int i;
  int v8;
  int v9;
  int v10;
  for ( i = 0; *a1 && i < a2; ++i )
  {
    v8 = 0;
    while ( 1 )
    {
      v10 = (char)*a1;
      if ( v10 <= 47 || v10 > 57 )
        break;
      v8 = 10 * v8 + v10 - 48;
      ++a1;
    }
    *(_WORD *)(a4 + 2 * i) = sqlite3LogEst((unsigned int)v8);
    if ( *a1 == 32 )
      ++a1;
  }
  *(_BYTE *)(a5 + 55) &= 0xFBu;
  *(_BYTE *)(a5 + 55) &= 0xBFu;
  while ( 1 )
  {
    result = *a1;
    if ( !(_BYTE)result )
      break;
    if ( sqlite3_strglob("unordered*", a1) )
    {
      if ( sqlite3_strglob("sz=[0-9]*", a1) )
      {
        if ( !sqlite3_strglob("noskipscan*", a1) )
          *(_BYTE *)(a5 + 55) |= 0x40u;
      }
      else
      {
        v9 = sqlite3Atoi(a1 + 3);
        if ( v9 <= 1 )
          v9 = 2;
        *(_WORD *)(a5 + 48) = sqlite3LogEst(v9);
      }
    }
    else
    {
      *(_BYTE *)(a5 + 55) |= 4u;
    }
    while ( *a1 && *a1 != 32 )
      ++a1;
    while ( *a1 == 32 )
      ++a1;
  }
  return result;
}
/////
__cdecl sqlite3AnalysisLoad(_DWORD *a1, int a2)
{
  _DWORD *i;
  _DWORD *j;
  _DWORD *k;
  int v6;
  int v7;
  int (__cdecl *v8)(int, int, int, char);
  int v9;
  _DWORD *v10;
  _BYTE *v11;
  unsigned int v12;
  v12 = __readgsdword(0x14u);
  v6 = 0;
  v7 = *(_DWORD *)(16 * a2 + a1[4] + 12);
  for ( i = *(_DWORD **)(v7 + 16); i; i = (_DWORD *)*i )
    *(_DWORD *)(i[2] + 36) &= 0xFFFFFFEF;
  for ( j = *(_DWORD **)(v7 + 32); j; j = (_DWORD *)*j )
    *(_BYTE *)(j[2] + 55) &= 0x7Fu;
  v10 = a1;
  v11 = *(_BYTE **)(16 * a2 + a1[4]);
  if ( sqlite3FindTable((int)a1, "sqlite_stat1", v11) )
  {
    v8 = (int (__cdecl *)(int, int, int, char))sqlite3MPrintf(
                                                 (int)a1,
                                                 (int)"SELECT tbl,idx,stat FROM %Q.sqlite_stat1",
                                                 v11);
    if ( v8 )
    {
      v6 = sqlite3_exec(a1, v8, analysisLoader, &v10, 0);
      sqlite3DbFree(a1, v8);
    }
    else
    {
      v6 = 7;
    }
  }
  for ( k = *(_DWORD **)(v7 + 32); k; k = (_DWORD *)*k )
  {
    v9 = k[2];
    if ( *(char *)(v9 + 55) >= 0 )
      sqlite3DefaultRowEst(v9);
  }
  if ( v6 == 7 )
    sqlite3OomFault((int)a1);
  return v6;
}
/////
__cdecl resolveAttachExpr(int *a1, _DWORD *a2)
{
  _BOOL4 v3;
  v3 = 0;
  if ( a2 )
  {
    if ( *(_BYTE *)a2 == 59 )
      *(_BYTE *)a2 = 115;
    else
      v3 = sqlite3ResolveExprNames(a1, a2);
  }
  return v3;
}
/////
__cdecl sqlite3DbIsNamed(int a1, int a2, unsigned __int8 *a3)
{
  return !sqlite3StrICmp(*(_BYTE **)(16 * a2 + *(_DWORD *)(a1 + 16)), a3) || !a2 && !sqlite3StrICmp("main", a3);
}
/////
__cdecl sqlite3FixExpr(int a1, int a2)
{
  while ( a2 )
  {
    if ( !*(_BYTE *)(a1 + 8) )
      *(_DWORD *)(a2 + 4) |= 0x40000000u;
    if ( *(_BYTE *)a2 == 0x99 )
    {
      if ( !*(_BYTE *)(**(_DWORD **)a1 + 161) )
      {
        sqlite3ErrorMsg(*(_DWORD *)a1, (int)"%s cannot use variables", *(_DWORD *)(a1 + 16));
        return 1;
      }
      *(_BYTE *)a2 = 119;
    }
    if ( (*(_DWORD *)(a2 + 4) & 0x804000) != 0 )
      break;
    if ( (*(_DWORD *)(a2 + 4) & 0x800) != 0 )
    {
      if ( sqlite3FixSelect(a1, *(_DWORD *)(a2 + 20)) )
        return 1;
    }
    else if ( sqlite3FixExprList(a1, *(_DWORD **)(a2 + 20)) )
    {
      return 1;
    }
    if ( sqlite3FixExpr(a1, *(_DWORD *)(a2 + 16)) )
      return 1;
    a2 = *(_DWORD *)(a2 + 12);
  }
  return 0;
}
/////
__cdecl sqlite3AuthCheck(int a1, int a2, int a3, int a4, int a5)
{
  int v6;
  int v7;
  v7 = *(_DWORD *)a1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 161) || *(_BYTE *)(a1 + 204) )
    return 0;
  if ( !*(_DWORD *)(v7 + 328) )
    return 0;
  v6 = (*(int (__cdecl **)(_DWORD, int, int, int, int, _DWORD))(v7 + 328))(
         *(_DWORD *)(v7 + 332),
         a2,
         a3,
         a4,
         a5,
         *(_DWORD *)(a1 + 244));
  if ( v6 == 1 )
  {
    sqlite3ErrorMsg(a1, (int)"not authorized");
    *(_DWORD *)(a1 + 12) = 23;
  }
  else if ( v6 )
  {
    if ( v6 != 2 )
    {
      v6 = 1;
      sqliteAuthBadReturnCode(a1);
    }
  }
  return v6;
}
/////
__cdecl findBtree(int *a1, int a2, int a3)
{
  int v4;
  int v5;
  int s;
  int (__cdecl *v7)(int, int, int, char);
  int v8;
  unsigned int v9;
  v9 = __readgsdword(0x14u);
  v5 = sqlite3FindDbName(a2, a3);
  if ( v5 == 1 )
  {
    v4 = 0;
    memset(&s, 0, 0x118u);
    s = a2;
    if ( sqlite3OpenTempDatabase((int)&s) )
    {
      sqlite3ErrorWithMsg(a1, v8, (int)"%s", v7);
      v4 = 1;
    }
    sqlite3DbFree(a1, v7);
    sqlite3ParserReset(&s);
    if ( v4 )
      return 0;
  }
  if ( v5 >= 0 )
    return *(_DWORD *)(16 * v5 + *(_DWORD *)(a2 + 16) + 4);
  sqlite3ErrorWithMsg(a1, 1, (int)"unknown database %s", a3);
  return 0;
}
/////
__cdecl sqlite3_backup_finish(int *a1)
{
  int v2;
  int v3;
  _DWORD *i;
  int v5;
  int v6;
  if ( !a1 )
    return 0;
  v5 = a1[5];
  sqlite3_mutex_enter(*(_DWORD *)(v5 + 12));
  sqlite3BtreeEnter(a1[6]);
  if ( *a1 )
    sqlite3_mutex_enter(*(_DWORD *)(*a1 + 12));
  if ( *a1 )
    --*(_DWORD *)(a1[6] + 16);
  if ( a1[10] )
  {
    v2 = sqlite3BtreePager(a1[6]);
    for ( i = (_DWORD *)sqlite3PagerBackupPtr(v2); a1 != (int *)*i; i = (_DWORD *)(*i + 44) )
      ;
    *i = a1[11];
  }
  sqlite3BtreeRollback(a1[1], 0, 0);
  if ( a1[7] == 101 )
    v3 = 0;
  else
    v3 = a1[7];
  v6 = v3;
  if ( *a1 )
  {
    sqlite3Error((int *)*a1, v3);
    sqlite3LeaveMutexAndCloseZombie(*a1);
  }
  sqlite3BtreeLeave(a1[6]);
  if ( *a1 )
    sub_6CA0(a1);
  sqlite3LeaveMutexAndCloseZombie(v5);
  return v6;
}
/////
__cdecl backupUpdate(_DWORD *a1, unsigned int a2, int a3)
{
  _DWORD *result;
  int v4;
  do
  {
    if ( !isFatalError(a1[7]) && a2 < a1[4] )
    {
      sqlite3_mutex_enter(*(_DWORD *)(*a1 + 12));
      v4 = backupOnePage((int)a1, a2, a3, 1);
      sqlite3_mutex_leave(*(_DWORD *)(*a1 + 12));
      if ( v4 )
        a1[7] = v4;
    }
    result = (_DWORD *)a1[11];
    a1 = result;
  }
  while ( result );
  return result;
}
/////
__cdecl sqlite3BitvecDestroy(int a1)
{
  int result;
  unsigned int i;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 8) )
    {
      for ( i = 0; i <= 0x7C; ++i )
        sqlite3BitvecDestroy(*(_DWORD *)(a1 + 4 * i + 12));
    }
    result = sub_6CA0(a1);
  }
  return result;
}
/////
__cdecl sqlite3BtreeEnter(int a1)
{
  int result;
  result = *(unsigned __int8 *)(a1 + 9);
  if ( (_BYTE)result )
  {
    ++*(_DWORD *)(a1 + 12);
    result = *(unsigned __int8 *)(a1 + 10);
    if ( !(_BYTE)result )
      result = btreeLockCarefully(a1);
  }
  return result;
}
/////
__cdecl btreeLockCarefully(int a1)
{
  int result;
  int i;
  int j;
  if ( sqlite3_mutex_try(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 60)) )
  {
    for ( i = *(_DWORD *)(a1 + 24); i; i = *(_DWORD *)(i + 24) )
    {
      if ( *(_BYTE *)(i + 10) )
        unlockBtreeMutex(i);
    }
    lockBtreeMutex(a1);
    result = *(_DWORD *)(a1 + 24);
    for ( j = result; j; j = result )
    {
      if ( *(_DWORD *)(j + 12) )
        lockBtreeMutex(j);
      result = *(_DWORD *)(j + 24);
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)a1;
    result = a1;
    *(_BYTE *)(a1 + 10) = 1;
  }
  return result;
}
/////
__cdecl sqlite3BtreeLeave(int a1)
{
  int result;
  result = *(unsigned __int8 *)(a1 + 9);
  if ( (_BYTE)result )
  {
    result = --*(_DWORD *)(a1 + 12);
    if ( !result )
      result = unlockBtreeMutex(a1);
  }
  return result;
}
/////
__cdecl btreeLeaveAll(int a1)
{
  int result;
  int i;
  int v3;
  for ( i = 0; ; ++i )
  {
    result = *(_DWORD *)(a1 + 20);
    if ( i >= result )
      break;
    v3 = *(_DWORD *)(16 * i + *(_DWORD *)(a1 + 16) + 4);
    if ( v3 )
      sqlite3BtreeLeave(v3);
  }
  return result;
}
/////
__cdecl querySharedCacheTableLock(int a1, int a2, char a3)
{
  __int16 v4;
  int i;
  int v6;
  v6 = *(_DWORD *)(a1 + 4);
  if ( !*(_BYTE *)(a1 + 9) )
    return 0;
  if ( a1 != *(_DWORD *)(v6 + 80) && (*(_WORD *)(v6 + 24) & 0x40) != 0 )
    return 262;
  for ( i = *(_DWORD *)(v6 + 76); ; i = *(_DWORD *)(i + 12) )
  {
    if ( !i )
      return 0;
    if ( a1 != *(_DWORD *)i && a2 == *(_DWORD *)(i + 4) && a3 != *(_BYTE *)(i + 8) )
      break;
  }
  if ( a3 == 2 )
  {
    v4 = *(_WORD *)(v6 + 24);
    LOBYTE(v4) = v4 | 0x80;
    *(_WORD *)(v6 + 24) = v4;
  }
  return 262;
}
/////
__cdecl invalidateIncrblobCursors(int a1, int a2, __int64 a3, int a4)
{
  __int64 result;
  int i;
  if ( *(_BYTE *)(a1 + 11) )
  {
    *(_BYTE *)(a1 + 11) = 0;
    for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8); i; i = *(_DWORD *)(i + 24) )
    {
      if ( (*(_BYTE *)(i + 1) & 0x10) != 0 )
      {
        *(_BYTE *)(a1 + 11) = 1;
        if ( a2 == *(_DWORD *)(i + 56) && (a4 || (result = a3 ^ *(_QWORD *)(i + 28)) == 0) )
          *(_BYTE *)i = 1;
      }
    }
  }
  return result;
}
/////
__cdecl btreeReleaseAllCursorPages(int a1)
{
  int result;
  int i;
  result = *(unsigned __int8 *)(a1 + 60);
  if ( (result & 0x80u) == 0 )
  {
    for ( i = 0; i < *(char *)(a1 + 60); ++i )
      releasePageNotNull(*(_DWORD *)(a1 + 4 * (i + 28)));
    releasePageNotNull(*(_DWORD *)(a1 + 108));
    result = a1;
    *(_BYTE *)(a1 + 60) = -1;
  }
  return result;
}
/////
__cdecl saveCursorPosition(int a1)
{
  int v2;
  if ( (*(_BYTE *)(a1 + 1) & 0x40) != 0 )
    return 2835;
  if ( *(_BYTE *)a1 == 2 )
    *(_BYTE *)a1 = 0;
  else
    *(_DWORD *)(a1 + 4) = 0;
  v2 = saveCursorKey(a1);
  if ( !v2 )
  {
    btreeReleaseAllCursorPages(a1);
    *(_BYTE *)a1 = 3;
  }
  *(_BYTE *)(a1 + 1) &= 0xF1u;
  return v2;
}
/////
__cdecl saveAllCursors(int a1, int a2, int a3)
{
  int i;
  for ( i = *(_DWORD *)(a1 + 8); i && (i == a3 || a2 && a2 != *(_DWORD *)(i + 56)); i = *(_DWORD *)(i + 24) )
    ;
  if ( i )
    return saveCursorsOnList(i, a2, a3);
  if ( a3 )
    *(_BYTE *)(a3 + 1) &= 0xDFu;
  return 0;
}
/////
__cdecl btreeMoveto(int a1, unsigned __int8 *a2, __int64 a3, char a4, int *a5)
{
  int v6;
  int v7;
  int v8;
  if ( !a2 )
  {
    v7 = 0;
LABEL_8:
    v6 = sqlite3BtreeMovetoUnpacked(a1, v7, a3, a4, a5);
    goto LABEL_9;
  }
  v8 = *(_DWORD *)(a1 + 104);
  v7 = sqlite3VdbeAllocUnpackedRecord(v8);
  if ( !v7 )
    return 7;
  sqlite3VdbeRecordUnpack(v8, a3, a2, v7);
  if ( *(_WORD *)(v7 + 8) && *(_WORD *)(v7 + 8) <= *(_WORD *)(v8 + 8) )
    goto LABEL_8;
  v6 = sqlite3CorruptError(65301);
LABEL_9:
  if ( v7 )
    sqlite3DbFree(*(_DWORD **)(*(_DWORD *)(a1 + 104) + 12), (int (__cdecl *)(int, int, int, char))v7);
  return v6;
}
/////
__cdecl ptrmapPageno(int a1, unsigned int a2)
{
  unsigned int v3;
  if ( a2 <= 1 )
    return 0;
  v3 = (a2 - 2) / (*(_DWORD *)(a1 + 40) / 5u + 1) * (*(_DWORD *)(a1 + 40) / 5u + 1) + 2;
  if ( v3 == (unsigned int)sqlite3PendingByte / *(_DWORD *)(a1 + 36) + 1 )
    v3 = (a2 - 2) / (*(_DWORD *)(a1 + 40) / 5u + 1) * (*(_DWORD *)(a1 + 40) / 5u + 1) + 3;
  return v3;
}
/////
__cdecl ptrmapGet(int *a1, unsigned int a2, _BYTE *a3, unsigned __int32 *a4)
{
  int result;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  v10 = __readgsdword(0x14u);
  v6 = ptrmapPageno((int)a1, a2);
  v7 = sqlite3PagerGet(*a1, v6, (int)&v5, 0);
  if ( v7 )
    return v7;
  v8 = sqlite3PagerGetData(v5);
  v9 = 5 * (a2 - v6) - 5;
  if ( v9 >= 0 )
  {
    *a3 = *(_BYTE *)(v9 + v8);
    if ( a4 )
      *a4 = sqlite3Get4byte((unsigned int *)(v9 + 1 + v8));
    sqlite3PagerUnref(v5);
    if ( *a3 && *a3 <= 5u )
      result = 0;
    else
      result = sqlite3CorruptError((int)&loc_10013);
  }
  else
  {
    sqlite3PagerUnref(v5);
    result = sqlite3CorruptError((int)&loc_1000B);
  }
  return result;
}
/////
__cdecl btreeParseCellAdjustSizeForOverflow(int a1, __int16 a2, int a3)
{
  int result;
  int v4;
  int v5;
  v4 = *(unsigned __int16 *)(a1 + 16);
  v5 = (*(_DWORD *)(a3 + 12) - v4) % (unsigned int)(*(_DWORD *)(*(_DWORD *)(a1 + 52) + 40) - 4) + v4;
  if ( v5 > *(unsigned __int16 *)(a1 + 14) )
    *(_WORD *)(a3 + 16) = v4;
  else
    *(_WORD *)(a3 + 16) = v5;
  result = a3;
  *(_WORD *)(a3 + 18) = *(_WORD *)(a3 + 8) + *(_WORD *)(a3 + 16) - a2 + 4;
  return result;
}
/////
__cdecl btreeParseCellPtrNoPayload(int a1, int a2, int a3)
{
  int result;
  *(_WORD *)(a3 + 18) = (unsigned __int8)sqlite3GetVarint((unsigned __int8 *)(a2 + 4), (_DWORD *)a3) + 4;
  *(_DWORD *)(a3 + 12) = 0;
  *(_WORD *)(a3 + 16) = 0;
  result = a3;
  *(_DWORD *)(a3 + 8) = 0;
  return result;
}
/////
__cdecl btreeParseCellPtrIndex(int a1, int a2, int a3)
{
  int result;
  char *v4;
  char *v5;
  unsigned int v6;
  char *v7;
  v4 = (char *)(*(unsigned __int8 *)(a1 + 10) + a2);
  v6 = (unsigned __int8)*v4;
  if ( v6 > 0x7F )
  {
    v7 = v4 + 8;
    v6 &= 0x7Fu;
    do
      v6 = (v6 << 7) | *++v4 & 0x7F;
    while ( *v4 < 0 && v4 < v7 );
  }
  v5 = v4 + 1;
  *(_DWORD *)a3 = v6;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 12) = v6;
  *(_DWORD *)(a3 + 8) = v5;
  if ( v6 > *(unsigned __int16 *)(a1 + 14) )
    return btreeParseCellAdjustSizeForOverflow(a1, a2, a3);
  *(_WORD *)(a3 + 18) = v6 + (_WORD)v5 - a2;
  if ( *(_WORD *)(a3 + 18) <= 3u )
    *(_WORD *)(a3 + 18) = 4;
  result = a3;
  *(_WORD *)(a3 + 16) = v6;
  return result;
}
/////
__cdecl cellSizePtrNoPayload(int a1, int a2)
{
  char *v2;
  unsigned int v4;
  v4 = a2 + 4;
  do
    v2 = (char *)v4++;
  while ( *v2 < 0 && v4 < a2 + 13 );
  return v4 - a2;
}
/////
__cdecl ptrmapPutOvflPtr(int a1, int a2, unsigned int a3, int *a4)
{
  unsigned __int32 v5;
  char v6[12];
  unsigned int v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned int v10;
  v10 = __readgsdword(0x14u);
  if ( !*a4 )
  {
    (*(void (__cdecl **)(int, unsigned int, char *))(a1 + 80))(a1, a3, v6);
    if ( v8 < v7 )
    {
      if ( *(_DWORD *)(a2 + 60) < a3 || *(_DWORD *)(a2 + 60) >= v8 + a3 )
      {
        v5 = sqlite3Get4byte((unsigned int *)(v9 - 4 + a3));
        ptrmapPut(*(int **)(a1 + 52), v5, 3, *(_DWORD *)(a1 + 4), a4);
      }
      else
      {
        *a4 = sqlite3CorruptError((int)&loc_1014D);
      }
    }
  }
  return __readgsdword(0x14u) ^ v10;
}
/////
__cdecl decodeFlags(int a1, int a2)
{
  void *v2;
  int v4;
  unsigned int v5;
  *(_BYTE *)(a1 + 8) = a2 >> 3;
  v5 = a2 & 0xFFFFFFF7;
  *(_BYTE *)(a1 + 10) = 4 * (1 - *(_BYTE *)(a1 + 8));
  *(_DWORD *)(a1 + 76) = cellSizePtr;
  v4 = *(_DWORD *)(a1 + 52);
  if ( v5 == 5 )
  {
    *(_BYTE *)(a1 + 2) = 1;
    if ( *(_BYTE *)(a1 + 8) )
    {
      *(_BYTE *)(a1 + 3) = 1;
      v2 = btreeParseCellPtr;
    }
    else
    {
      *(_BYTE *)(a1 + 3) = 0;
      *(_DWORD *)(a1 + 76) = cellSizePtrNoPayload;
      v2 = btreeParseCellPtrNoPayload;
    }
    *(_DWORD *)(a1 + 80) = v2;
    *(_WORD *)(a1 + 14) = *(_WORD *)(v4 + 30);
    *(_WORD *)(a1 + 16) = *(_WORD *)(v4 + 32);
  }
  else
  {
    if ( v5 != 2 )
      return sqlite3CorruptError((int)&loc_10325);
    *(_BYTE *)(a1 + 2) = 0;
    *(_BYTE *)(a1 + 3) = 0;
    *(_DWORD *)(a1 + 80) = btreeParseCellPtrIndex;
    *(_WORD *)(a1 + 14) = *(_WORD *)(v4 + 26);
    *(_WORD *)(a1 + 16) = *(_WORD *)(v4 + 28);
  }
  *(_BYTE *)(a1 + 11) = *(_BYTE *)(v4 + 21);
  return 0;
}
/////
__cdecl btreeInitPage(int a1)
{
  int result;
  _DWORD *v2;
  unsigned __int8 *v3;
  v2 = *(_DWORD **)(a1 + 52);
  v3 = (unsigned __int8 *)(*(_DWORD *)(a1 + 56) + *(unsigned __int8 *)(a1 + 9));
  if ( decodeFlags(a1, *v3) )
    return sqlite3CorruptError(66491);
  *(_WORD *)(a1 + 26) = v2[9] - 1;
  *(_BYTE *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 18) = *(unsigned __int8 *)(a1 + 9) + *(unsigned __int8 *)(a1 + 10) + 8;
  *(_DWORD *)(a1 + 64) = &v3[*(unsigned __int8 *)(a1 + 10) + 8];
  *(_DWORD *)(a1 + 60) = v2[10] + *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a1 + 10) + *(_DWORD *)(a1 + 56);
  *(_WORD *)(a1 + 24) = _byteswap_ushort(*(_WORD *)(v3 + 3));
  if ( *(unsigned __int16 *)(a1 + 24) > (v2[9] - 8) / 6u )
    return sqlite3CorruptError(66505);
  *(_DWORD *)(a1 + 20) = -1;
  *(_BYTE *)a1 = 1;
  if ( (*(_DWORD *)(v2[1] + 28) & 0x200000) != 0 )
    result = btreeCellSizeCheck(a1);
  else
    result = 0;
  return result;
}
/////
__cdecl btreePageFromDbPage(int a1, int a2, int a3)
{
  char v3;
  int v5;
  v5 = sqlite3PagerGetExtra(a1);
  if ( a2 != *(_DWORD *)(v5 + 4) )
  {
    *(_DWORD *)(v5 + 56) = sqlite3PagerGetData(a1);
    *(_DWORD *)(v5 + 72) = a1;
    *(_DWORD *)(v5 + 52) = a3;
    *(_DWORD *)(v5 + 4) = a2;
    if ( a2 == 1 )
      v3 = 100;
    else
      v3 = 0;
    *(_BYTE *)(v5 + 9) = v3;
  }
  return v5;
}
/////
__cdecl btreePageLookup(int *a1, int a2)
{
  int result;
  int v3;
  v3 = sqlite3PagerLookup(*a1, a2);
  if ( v3 )
    result = btreePageFromDbPage(v3, a2, (int)a1);
  else
    result = 0;
  return result;
}
/////
__cdecl releasePageNotNull(int a1)
{
  return sqlite3PagerUnrefNotNull(*(_DWORD *)(a1 + 72));
}
/////
__cdecl releasePage(int a1)
{
  double *result;
  result = &GLOBAL_OFFSET_TABLE_;
  if ( a1 )
    result = releasePageNotNull(a1);
  return result;
}
/////
__cdecl pageReinit(int a1)
{
  int result;
  _BYTE *v2;
  v2 = (_BYTE *)sqlite3PagerGetExtra(a1);
  result = (unsigned __int8)*v2;
  if ( (_BYTE)result )
  {
    *v2 = 0;
    result = sqlite3PagerPageRefcount(a1);
    if ( result > 1 )
      result = btreeInitPage((int)v2);
  }
  return result;
}
/////
__cdecl sqlite3BtreeSetSpillSize(int a1, int a2)
{
  int *v3;
  int v4;
  v3 = *(int **)(a1 + 4);
  sqlite3BtreeEnter(a1);
  v4 = sqlite3PagerSetSpillsize(*v3, a2);
  sqlite3BtreeLeave(a1);
  return v4;
}
/////
__cdecl unsetJoinExpr(double *a1, int a2)
{
  double *result;
  int i;
  result = &GLOBAL_OFFSET_TABLE_;
  while ( a1 )
  {
    if ( (*((_DWORD *)a1 + 1) & 1) != 0 && (a2 < 0 || a2 == *((__int16 *)a1 + 18)) )
      *((_DWORD *)a1 + 1) &= 0xFFFFFFFE;
    if ( *(_BYTE *)a1 == 0xA9 && *((_DWORD *)a1 + 5) )
    {
      for ( i = 0; i < **((_DWORD **)a1 + 5); ++i )
        unsetJoinExpr(*(_DWORD *)(16 * i + *((_DWORD *)a1 + 5) + 4), a2);
    }
    unsetJoinExpr(*((_DWORD *)a1 + 3), a2);
    result = (double *)*((_DWORD *)a1 + 4);
    a1 = result;
  }
  return result;
}
/////
__cdecl codeOffset(_DWORD *a1, int a2, int a3)
{
  double *result;
  result = &GLOBAL_OFFSET_TABLE_;
  if ( a2 > 0 )
    result = (double *)sqlite3VdbeAddOp3(a1, 48, a2, a3, 1);
  return result;
}
/////
__cdecl selectInnerLoop(int *a1, int a2, int a3, _DWORD *a4, int a5, unsigned __int8 *a6, int a7, int a8)
{
  int v8;
  int v9;
  _DWORD *v10;
  int v12;
  char v13;
  int k;
  int i;
  int j;
  int l;
  int m;
  int v19;
  int v20;
  int v21;
  int v22;
  _DWORD *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _DWORD *v28;
  int v29;
  int v30;
  char *s;
  int v32;
  int v33;
  int v34;
  int *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  char v45;
  unsigned int v46;
  v12 = (int)a4;
  v46 = __readgsdword(0x14u);
  v23 = (_DWORD *)a1[2];
  v24 = *a6;
  v25 = *((_DWORD *)a6 + 1);
  v20 = 0;
  if ( a5 )
    v8 = *(unsigned __int8 *)(a5 + 1);
  else
    v8 = 0;
  v26 = v8;
  if ( a4 && !*a4 )
    v12 = 0;
  if ( !v12 && !v8 )
    codeOffset(v23, *(_DWORD *)(a2 + 12), a7);
  v19 = **(_DWORD **)(a2 + 28);
  if ( *((_DWORD *)a6 + 3) )
  {
    if ( v19 + *((_DWORD *)a6 + 3) > a1[11] )
      a1[11] += v19;
  }
  else
  {
    if ( v12 )
    {
      v20 = **(_DWORD **)v12;
      if ( (*(_BYTE *)(v12 + 32) & 1) == 0 )
        ++v20;
      a1[11] += v20;
    }
    *((_DWORD *)a6 + 3) = a1[11] + 1;
    a1[11] += v19;
  }
  *((_DWORD *)a6 + 4) = v19;
  v27 = *((_DWORD *)a6 + 3);
  v21 = v27;
  if ( a3 < 0 )
  {
    if ( v24 != 3 )
    {
      v13 = v24 == 10 || v24 == 9 || v24 == 13;
      if ( v12 && !v26 && v24 != 12 && v24 != 14 )
      {
        v13 |= 0xCu;
        for ( i = *(_DWORD *)(v12 + 4); i < **(_DWORD **)v12; ++i )
        {
          if ( *(_WORD *)(16 * i + *(_DWORD *)v12 + 16) )
            *(_WORD *)(16 * (*(unsigned __int16 *)(16 * i + *(_DWORD *)v12 + 16) - 1) + *(_DWORD *)(a2 + 28) + 16) = i - *(_WORD *)(v12 + 4) + 1;
        }
        v28 = *(_DWORD **)(a2 + 28);
        for ( j = 0; j < *v28; ++j )
        {
          if ( LOWORD(v28[4 * j + 4]) )
          {
            --v19;
            v21 = 0;
          }
        }
      }
      v44 = v27;
      v45 = v13;
      if ( *(_DWORD *)(a2 + 8) && (v13 & 8) != 0 && v20 > 0 )
      {
        *(_DWORD *)(v12 + 36) = &v44;
        v21 = 0;
      }
      else
      {
        innerLoopLoadRow((int)a1, a2, (int)&v44);
      }
    }
  }
  else
  {
    for ( k = 0; k < v19; ++k )
      sqlite3VdbeAddOp3(v23, 89, a3, k, v27 + k);
  }
  if ( v26 )
  {
    v9 = *(unsigned __int8 *)(a5 + 1);
    if ( v9 == 1 )
    {
      sqlite3VdbeChangeToNoop((_DWORD **)v23, *(_DWORD *)(a5 + 8));
    }
    else if ( v9 == 2 )
    {
      v29 = a1[11] + 1;
      a1[11] += v19;
      sqlite3VdbeChangeToNoop((_DWORD **)v23, *(_DWORD *)(a5 + 8));
      v10 = sqlite3VdbeGetOp(v23, *(_DWORD *)(a5 + 8));
      *(_BYTE *)v10 = 72;
      v10[1] = 1;
      v10[2] = v29;
      v30 = sqlite3VdbeCurrentAddr((int)v23) + v19;
      for ( l = 0; l < v19; ++l )
      {
        s = sqlite3ExprCollSeq(a1, *(unsigned __int8 **)(16 * l + *(_DWORD *)(a2 + 28) + 4));
        if ( l >= v19 - 1 )
          sqlite3VdbeAddOp3(v23, 53, v27 + l, a7, l + v29);
        else
          sqlite3VdbeAddOp3(v23, 52, v27 + l, v30, l + v29);
        sqlite3VdbeChangeP4((int)v23, -1, s, -2);
        sqlite3VdbeChangeP5((int)v23, 0x80u);
      }
      sqlite3VdbeAddOp3(v23, 77, v27, v29, v19 - 1);
    }
    else
    {
      codeDistinct((int)a1, *(_DWORD *)(a5 + 4), a7, v19, v27);
    }
    if ( !v12 )
      codeOffset(v23, *(_DWORD *)(a2 + 12), a7);
  }
  switch ( v24 )
  {
    case 1:
      v43 = sqlite3GetTempReg((int)a1);
      sqlite3VdbeAddOp3(v23, 91, v27, v19, v43);
      sqlite3VdbeAddOp4Int(v23, 130, v25, v43, v27, v19);
      sqlite3ReleaseTempReg((int)a1, v43);
      break;
    case 2:
      sqlite3VdbeAddOp3(v23, 132, v25, v27, v19);
      break;
    case 3:
      sqlite3VdbeAddOp2(v23, 69, 1, v25);
      break;
    case 5:
    case 6:
    case 12:
    case 14:
      v40 = sqlite3GetTempRange(a1, v20 + 1); 
      sqlite3VdbeAddOp3(v23, 91, v27, v19, v40 + v20);
      if ( v24 == 6 )
      {
        v41 = sqlite3VdbeCurrentAddr((int)v23) + 4;
        sqlite3VdbeAddOp4Int(v23, 30, v25 + 1, v41, v40, 0);
        sqlite3VdbeAddOp4Int(v23, 130, v25 + 1, v40, v27, v19);
      }
      if ( v12 )
      {
        pushOntoSorter(a1, v12, a2, v40 + v20, v21, 1, v20);
      }
      else
      {
        v42 = sqlite3GetTempReg((int)a1);
        sqlite3VdbeAddOp2(v23, 120, v25, v42);
        sqlite3VdbeAddOp3(v23, 121, v25, v40, v42);
        sqlite3VdbeChangeP5((int)v23, 8u);
        sqlite3ReleaseTempReg((int)a1, v42);
      }
      sqlite3ReleaseTempRange((int)a1, v40, v20 + 1);
      break;
    case 7:
    case 8:
      v22 = 0;
      v35 = (int *)*((_DWORD *)a6 + 6);
      v36 = *v35;
      v37 = sqlite3GetTempReg((int)a1);
      v38 = sqlite3GetTempRange(a1, v36 + 2);
      v39 = v38 + v36 + 1;
      if ( v24 == 8 )
        v22 = sqlite3VdbeAddOp4Int(v23, 30, v25 + 1, 0, v27, v19);
      sqlite3VdbeAddOp3(v23, 91, v27, v19, v39);
      if ( v24 == 8 )
      {
        sqlite3VdbeAddOp2(v23, 130, v25 + 1, v39);
        sqlite3VdbeChangeP5((int)v23, 0x10u);
      }
      for ( m = 0; m < v36; ++m )
        sqlite3VdbeAddOp2(v23, 78, LOWORD(v35[4 * m + 4]) + v27 - 1, m + v38);
      sqlite3VdbeAddOp2(v23, 119, v25, v38 + v36);
      sqlite3VdbeAddOp3(v23, 91, v38, v36 + 2, v37);
      sqlite3VdbeAddOp4Int(v23, 130, v25, v37, v38, v36 + 2);
      if ( v22 )
        sqlite3VdbeJumpHere(v23, v22);
      sqlite3ReleaseTempReg((int)a1, v37);
      sqlite3ReleaseTempRange((int)a1, v38, v36 + 2);
      break;
    case 9:
    case 13:
      if ( v12 )
        goto LABEL_80;
      if ( v24 == 13 )
        sqlite3VdbeAddOp1(v23, 14, *((_DWORD *)a6 + 1));
      else
        sqlite3VdbeAddOp2(v23, 80, v27, v19);
      break;
    case 10:
      if ( v12 )
        goto LABEL_80;
      break;
    case 11:
      if ( v12 )
        goto LABEL_80;
      v34 = sqlite3GetTempReg((int)a1);
      sqlite3VdbeAddOp4(v23, 91, v27, v19, v34, *((char **)a6 + 5), v19);
      sqlite3VdbeAddOp4Int(v23, 130, v25, v34, v27, v19);
      sqlite3ReleaseTempReg((int)a1, v34);
      break;
    case 15:
      if ( v12 )
      {
LABEL_80:
        pushOntoSorter(a1, v12, a2, v27, v21, v19, v20);
      }
      else
      {
        v32 = *((_DWORD *)a6 + 2);
        v33 = sqlite3GetTempReg((int)a1);
        sqlite3VdbeAddOp2(v23, 50, v27, a8);
        sqlite3VdbeAddOp3(v23, 91, (v32 < 0) + v27, v19 - (v32 < 0), v33);
        if ( v32 >= 0 )
          sqlite3VdbeAddOp4Int(v23, 130, v25, v33, v27, v32);
        else
          sqlite3VdbeAddOp3(v23, 121, v25, v33, v27);
      }
      break;
    default:
      break;
  }
  if ( !v12 && *(_DWORD *)(a2 + 8) )
    sqlite3VdbeAddOp2(v23, 59, *(_DWORD *)(a2 + 8), a8);
  return __readgsdword(0x14u) ^ v46;
}
/////
__cdecl sqlite3ColumnsFromExprList(int *a1, int *a2, _WORD *a3, char ***a4)
{
  char *v4;
  char v5;
  int *v6;
  unsigned int v8;
  int v9;
  int j;
  char **v11;
  char **v12;
  int v13;
  char *s;
  int v15;
  _DWORD *i;
  int v17;
  int v19;
  unsigned int v20[6];
  v20[4] = __readgsdword(0x14u);
  v18 = *a1;
  sqlite3HashInit(v20);
  if ( a2 )
  {
    v13 = *a2;
    v11 = (char **)sqlite3DbMallocZero(v18, (unsigned int)(20 * v13));
    if ( v13 > 0x7FFF )
      v13 = 0x7FFF;
  }
  else
  {
    v13 = 0;
    v11 = 0;
  }
  *a3 = v13;
  *a4 = v11;
  v9 = 0;
  v12 = v11;
  while ( v9 < v13 && !*(_BYTE *)(v18 + 77) )
  {
    s = (char *)a2[4 * v9 + 2];
    if ( !s || (a2[4 * v9 + 3] & 0x300) != 0 )
    {
      for ( i = sqlite3ExprSkipCollateAndLikely((_DWORD *)a2[4 * v9 + 1]); *(_BYTE *)i == 0x8B; i = (_DWORD *)i[4] )
        ;
      if ( *(_BYTE *)i == 0xA4 )
      {
        v17 = *((__int16 *)i + 16);
        v19 = i[11];
        if ( v17 < 0 )
          v17 = *(__int16 *)(v19 + 40);
        if ( v17 < 0 )
          v4 = "rowid";
        else
          v4 = *(char **)(*(_DWORD *)(v19 + 4) + 20 * v17);
        s = v4;
      }
      else if ( *(_BYTE *)i == 59 )
      {
        s = (char *)i[2];
      }
      else
      {
        s = (char *)a2[4 * v9 + 2];
      }
    }
    if ( !s || sqlite3IsTrueOrFalse(s) )
      s = (char *)sqlite3MPrintf(v18, (int)"column%d", v9 + 1);
    else
      s = (char *)sqlite3DbStrDup(v18, s);
    v8 = 0;
    while ( s && sqlite3HashFind(v20, (unsigned __int8 *)s) )
    {
      v15 = sqlite3Strlen30(s);
      if ( v15 > 0 )
      {
        for ( j = v15 - 1; j > 0 && (sqlite3CtypeMap[(_DWORD)dword_0 + (unsigned __int8)s[j]] & 4) != 0; --j )
          ;
        if ( s[j] == 58 )
          v15 = j;
      }
      s = (char *)sqlite3MPrintf(v18, (int)"%.*z:%u", v15, s, ++v8);
      if ( v8 > 3 )
        sqlite3_randomness(4, &v8);
    }
    *v12 = s;
    v5 = sqlite3StrIHash(s);
    *((_BYTE *)v12 + 15) = v5;
    if ( s )
    {
      v6 = sqlite3HashInsert(v20, (unsigned __int8 *)s, (int *)v12);
      if ( v12 == (char **)v6 )
        sqlite3OomFault(v18);
    }
    ++v9;
    v12 += 5;
  }
  sqlite3HashClear(v20);
  if ( *(_BYTE *)(v18 + 77) )
  {
    for ( j = 0; j < v9; ++j )
      sqlite3DbFree((_DWORD *)v18, (int (__cdecl *)(int, int, int, char))v11[5 * j]);
    sqlite3DbFree((_DWORD *)v18, (int (__cdecl *)(int, int, int, char))v11);
    *a4 = 0;
    *a3 = 0;
    return 7;
  }
  return 0;
}
/////
__cdecl generateWithRecursiveQuery(int *a1, int a2, unsigned __int8 *a3)
{
  int v3;
  char v4;
  int v5;
  char v6;
  int v8;
  int v9;
  char v10;
  int i;
  _DWORD *v12;
  int v13;
  _DWORD *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  _DWORD *v20;
  int v21;
  int v22;
  char *v23;
  int v24;
  int v25;
  int v26;
  char v27[24];
  _DWORD *v28;
  unsigned int v29;
  v29 = __readgsdword(0x14u);
  v12 = *(_DWORD **)(a2 + 32);
  v13 = **(_DWORD **)(a2 + 28);
  v14 = (_DWORD *)a1[2];
  v15 = *(_DWORD *)(a2 + 52);
  v8 = 0;
  v9 = 0;
  if ( *(_DWORD *)(a2 + 68) )
  {
    sqlite3ErrorMsg((int)a1, (int)"cannot use window functions in recursive queries");
  }
  else if ( !sqlite3AuthCheck((int)a1, 33, 0, 0, 0) )
  {
    v16 = sqlite3VdbeMakeLabel((int)a1);
    *(_WORD *)(a2 + 2) = 320;
    computeLimitRegisters(a1, a2, v16);
    v17 = *(_DWORD *)(a2 + 60);
    v18 = *(_DWORD *)(a2 + 8);
    v19 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 60) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 12);
    v20 = *(_DWORD **)(a2 + 48);
    for ( i = 0; i < *v12; ++i )
    {
      if ( (v12[17 * i + 11] & 0x2000) != 0 )
      {
        v8 = v12[17 * i + 12];
        break;
      }
    }
    v3 = a1[10];
    a1[10] = v3 + 1;
    v21 = v3;
    if ( *(_BYTE *)a2 == 0x84 )
    {
      if ( v20 )
        v4 = 8;
      else
        v4 = 6;
      v10 = v4;
      v5 = a1[10];
      a1[10] = v5 + 1;
      v9 = v5;
      sqlite3SelectDestInit((int)v27, v10, v21);
    }
    else
    {
      if ( v20 )
        v6 = 7;
      else
        v6 = 5;
      sqlite3SelectDestInit((int)v27, v6, v21);
    }
    v22 = ++a1[11];
    sqlite3VdbeAddOp3(v14, 114, v8, v22, v13);
    if ( v20 )
    {
      v23 = (char *)multiSelectOrderByKeyInfo(a1, a2, 1);
      sqlite3VdbeAddOp4(v14, 100, v21, *v20 + 2, 0, v23, -9);
      v28 = v20;
    }
    else
    {
      sqlite3VdbeAddOp2(v14, 100, v21, v13);
    }
    if ( v9 )
    {
      *(_DWORD *)(a2 + 20) = sqlite3VdbeAddOp2(v14, 100, v9, 0);
      *(_DWORD *)(a2 + 4) |= 0x20u;
    }
    *(_DWORD *)(a2 + 48) = 0;
    *(_DWORD *)(v15 + 56) = 0;
    sqlite3VdbeExplain(a1, 1, (int)"SETUP");
    v24 = sqlite3Select(a1, v15, v27);
    *(_DWORD *)(v15 + 56) = a2;
    if ( !v24 )
    {
      v25 = sqlite3VdbeAddOp2(v14, 37, v21, v16);
      sqlite3VdbeAddOp1(v14, 128, v8);
      if ( v20 )
        sqlite3VdbeAddOp3(v14, 89, v21, *v20 + 1, v22);
      else
        sqlite3VdbeAddOp2(v14, 126, v21, v22);
      sqlite3VdbeAddOp1(v14, 122, v21);
      v26 = sqlite3VdbeMakeLabel((int)a1);
      codeOffset(v14, v19, v26);
      selectInnerLoop(a1, a2, v8, 0, 0, a3, v26, v16);
      if ( v18 )
        sqlite3VdbeAddOp2(v14, 59, v18, v16);
      sqlite3VdbeResolveLabel((int)v14, v26);
      if ( (*(_DWORD *)(a2 + 4) & 8) != 0 )
      {
        sqlite3ErrorMsg((int)a1, (int)"recursive aggregate queries not supported");
      }
      else
      {
        *(_DWORD *)(a2 + 52) = 0;
        sqlite3VdbeExplain(a1, 1, (int)"RECURSIVE STEP");
        sqlite3Select(a1, a2, v27);
        *(_DWORD *)(a2 + 52) = v15;
      }
      sqlite3VdbeGoto(v14, v25);
      sqlite3VdbeResolveLabel((int)v14, v16);
    }
    sqlite3ExprListDelete((_DWORD *)*a1, *(int (__cdecl **)(int, int, int, char))(a2 + 48));
    *(_DWORD *)(a2 + 48) = v20;
    *(_DWORD *)(a2 + 60) = v17;
  }
  return __readgsdword(0x14u) ^ v29;
}
/////
__cdecl multiSelect(int *a1, unsigned __int8 *a2, int a3)
{
  const char *v3;
  const char *v4;
  int v6;
  __int16 v7;
  int v8;
  int v9;
  const char *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  const char *v15;
  char *v16;
  char v17;
  int v18;
  double *v19;
  int v20;
  int v21;
  int v22;
  int j;
  unsigned __int8 *i;
  char **v25;
  int v26;
  int v27;
  int *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  _DWORD *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50[9];
  v50[7] = __readgsdword(0x14u);
  v18 = 0;
  v19 = 0;
  v26 = *a1;
  v27 = *((_DWORD *)a2 + 13);
  v43 = *(_DWORD *)a3;
  v44 = *(_DWORD *)(a3 + 4);
  v45 = *(_DWORD *)(a3 + 8);
  v46 = *(_DWORD *)(a3 + 12);
  v47 = *(_DWORD *)(a3 + 16);
  v48 = *(_DWORD *)(a3 + 20);
  v49 = *(_DWORD *)(a3 + 24);
  if ( *(_DWORD *)(v27 + 48) || *(_DWORD *)(v27 + 60) )
  {
    v3 = selectOpName(*a2);
    if ( *(_DWORD *)(v27 + 48) )
      v4 = "ORDER BY";
    else
      v4 = "LIMIT";
    sqlite3ErrorMsg((int)a1, (int)"%s clause should come after %s not before", v4, v3);
    v18 = 1;
    goto LABEL_69;
  }
  v28 = sqlite3GetVdbe(a1);
  if ( (_BYTE)v43 == 12 )
  {
    sqlite3VdbeAddOp2(v28, 100, v44, **((_DWORD **)a2 + 7));
    LOBYTE(v43) = 14;
  }
  if ( (*((_DWORD *)a2 + 1) & 0x400) != 0 )
  {
    v18 = multiSelectValues(a1, (int)a2, (unsigned __int8 *)&v43);
    if ( v18 >= 0 )
      goto LABEL_69;
    v18 = 0;
  }
  if ( (*((_DWORD *)a2 + 1) & 0x2000) != 0 )
  {
    generateWithRecursiveQuery(a1, (int)a2, (unsigned __int8 *)&v43);
    goto LABEL_52;
  }
  if ( *((_DWORD *)a2 + 12) )
    return multiSelectOrderBy(a1, a2, (unsigned __int8 *)a3);
  if ( !*(_DWORD *)(v27 + 52) )
  {
    sqlite3VdbeExplain(a1, 1, (int)"COMPOUND QUERY");
    sqlite3VdbeExplain(a1, 1, (int)"LEFT-MOST SUBQUERY");
  }
  v6 = *a2;
  if ( v6 == 133 )
  {
    v20 = 0;
    *(_DWORD *)(v27 + 8) = *((_DWORD *)a2 + 2);
    *(_DWORD *)(v27 + 12) = *((_DWORD *)a2 + 3);
    *(_DWORD *)(v27 + 60) = *((_DWORD *)a2 + 15);
    v18 = sqlite3Select(a1, v27, &v43);
    *((_DWORD *)a2 + 15) = 0;
    if ( !v18 )
    {
      *((_DWORD *)a2 + 13) = 0;
      *((_DWORD *)a2 + 2) = *(_DWORD *)(v27 + 8);
      *((_DWORD *)a2 + 3) = *(_DWORD *)(v27 + 12);
      if ( *((_DWORD *)a2 + 2) )
      {
        v20 = sqlite3VdbeAddOp1(v28, 20, *((_DWORD *)a2 + 2));
        if ( *((_DWORD *)a2 + 3) )
          sqlite3VdbeAddOp3(v28, 152, *((_DWORD *)a2 + 2), *((_DWORD *)a2 + 3) + 1, *((_DWORD *)a2 + 3));
      }
      sqlite3VdbeExplain(a1, 1, (int)"UNION ALL");
      v18 = sqlite3Select(a1, a2, &v43);
      v19 = (double *)*((_DWORD *)a2 + 13);
      *((_DWORD *)a2 + 13) = v27;
      *((_WORD *)a2 + 1) = sqlite3LogEstAdd(*((_WORD *)a2 + 1), *(_WORD *)(v27 + 2));
      if ( *(_DWORD *)(v27 + 60) )
      {
        if ( sqlite3ExprIsInteger(*(_DWORD **)(*(_DWORD *)(v27 + 60) + 12), v50) )
        {
          if ( v50[0] > 0 )
          {
            v7 = *((_WORD *)a2 + 1);
            if ( v7 > (__int16)sqlite3LogEst(v50[0]) )
              *((_WORD *)a2 + 1) = sqlite3LogEst(v50[0]);
          }
        }
      }
      if ( v20 )
        sqlite3VdbeJumpHere(v28, v20);
      goto LABEL_50;
    }
  }
  else
  {
    if ( v6 == 134 || v6 == 132 )
    {
      if ( (unsigned __int8)v43 == 1 )
      {
        v21 = v44;
        sqlite3SelectDestInit((int)v50, 1, v44);
      }
      else
      {
        v8 = a1[10];
        a1[10] = v8 + 1;
        v21 = v8;
        *((_DWORD *)a2 + 5) = sqlite3VdbeAddOp2(v28, 100, v8, 0);
        v9 = findRightmost((int)a2);
        *(_DWORD *)(v9 + 4) |= 0x20u;
        sqlite3SelectDestInit((int)v50, 1, v21);
      }
      v18 = sqlite3Select(a1, v27, v50);
      if ( v18 )
        goto LABEL_69;
      if ( *a2 == 0x86 )
        v17 = 2;
      else
        v17 = 1;
      *((_DWORD *)a2 + 13) = 0;
      v29 = *((_DWORD *)a2 + 15);
      *((_DWORD *)a2 + 15) = 0;
      LOBYTE(v50[0]) = v17;
      v10 = selectOpName(*a2);
      sqlite3VdbeExplain(a1, 1, (int)"%s USING TEMP B-TREE", v10);
      v18 = sqlite3Select(a1, a2, v50);
      v19 = (double *)*((_DWORD *)a2 + 13);
      *((_DWORD *)a2 + 13) = v27;
      *((_DWORD *)a2 + 12) = 0;
      if ( *a2 == 0x84 )
        *((_WORD *)a2 + 1) = sqlite3LogEstAdd(*((_WORD *)a2 + 1), *(_WORD *)(v27 + 2));
      sqlite3ExprDelete((_DWORD *)v26, *((_DWORD *)a2 + 15));
      *((_DWORD *)a2 + 15) = v29;
      *((_DWORD *)a2 + 2) = 0;
      *((_DWORD *)a2 + 3) = 0;
      if ( (unsigned __int8)v43 != 1 && !*(_BYTE *)(v26 + 77) )
      {
        v30 = sqlite3VdbeMakeLabel((int)a1);
        v31 = sqlite3VdbeMakeLabel((int)a1);
        computeLimitRegisters(a1, (int)a2, v30);
        sqlite3VdbeAddOp2(v28, 37, v21, v30);
        v32 = sqlite3VdbeCurrentAddr((int)v28);
        selectInnerLoop(a1, (int)a2, v21, 0, 0, (unsigned __int8 *)&v43, v31, v30);
        sqlite3VdbeResolveLabel((int)v28, v31);
        sqlite3VdbeAddOp2(v28, 5, v21, v32);
        sqlite3VdbeResolveLabel((int)v28, v30);
        sqlite3VdbeAddOp2(v28, 116, v21, 0);
      }
      goto LABEL_50;
    }
    v11 = a1[10];
    a1[10] = v11 + 1;
    v33 = v11;
    v12 = a1[10];
    a1[10] = v12 + 1;
    v34 = v12;
    *((_DWORD *)a2 + 5) = sqlite3VdbeAddOp2(v28, 100, v33, 0);
    v13 = findRightmost((int)a2);
    *(_DWORD *)(v13 + 4) |= 0x20u;
    sqlite3SelectDestInit((int)v50, 1, v33);
    v14 = sqlite3Select(a1, v27, v50);
    v18 = v14;
    if ( !v14 )
    {
      *((_DWORD *)a2 + 6) = sqlite3VdbeAddOp2(v28, 100, v34, 0);
      *((_DWORD *)a2 + 13) = 0;
      v35 = *((_DWORD *)a2 + 15);
      *((_DWORD *)a2 + 15) = 0;
      v50[1] = v34;
      v15 = selectOpName(*a2);
      sqlite3VdbeExplain(a1, 1, (int)"%s USING TEMP B-TREE", v15);
      v18 = sqlite3Select(a1, a2, v50);
      v19 = (double *)*((_DWORD *)a2 + 13);
      *((_DWORD *)a2 + 13) = v27;
      if ( *((_WORD *)a2 + 1) > *(_WORD *)(v27 + 2) )
        *((_WORD *)a2 + 1) = *(_WORD *)(v27 + 2);
      sqlite3ExprDelete((_DWORD *)v26, *((_DWORD *)a2 + 15));
      *((_DWORD *)a2 + 15) = v35;
      if ( !v18 )
      {
        v36 = sqlite3VdbeMakeLabel((int)a1);
        v37 = sqlite3VdbeMakeLabel((int)a1);
        computeLimitRegisters(a1, (int)a2, v36);
        sqlite3VdbeAddOp2(v28, 37, v33, v36);
        v38 = sqlite3GetTempReg((int)a1);
        v39 = sqlite3VdbeAddOp2(v28, 126, v33, v38);
        sqlite3VdbeAddOp4Int(v28, 29, v34, v37, v38, 0);
        sqlite3ReleaseTempReg((int)a1, v38);
        selectInnerLoop(a1, (int)a2, v33, 0, 0, (unsigned __int8 *)&v43, v37, v36);
        sqlite3VdbeResolveLabel((int)v28, v37);
        sqlite3VdbeAddOp2(v28, 5, v33, v39);
        sqlite3VdbeResolveLabel((int)v28, v36);
        sqlite3VdbeAddOp2(v28, 116, v34, 0);
        sqlite3VdbeAddOp2(v28, 116, v33, 0);
      }
    }
  }
LABEL_50:
  if ( !*((_DWORD *)a2 + 14) )
    sqlite3VdbeExplainPop((int)a1);
LABEL_52:
  if ( !a1[9] && (*((_DWORD *)a2 + 1) & 0x20) != 0 )
  {
    v40 = **((_DWORD **)a2 + 7);
    v41 = (_DWORD *)sqlite3KeyInfoAlloc(v26, v40, 1);
    if ( v41 )
    {
      v22 = 0;
      v25 = (char **)(v41 + 5);
      while ( v22 < v40 )
      {
        *v25 = multiSelectCollSeq(a1, (int)a2, v22);
        if ( !*v25 )
          *v25 = *(char **)(v26 + 8);
        ++v22;
        ++v25;
      }
      for ( i = a2; i; i = (unsigned __int8 *)*((_DWORD *)i + 13) )
      {
        for ( j = 0; j <= 1; ++j )
        {
          v42 = *(_DWORD *)&i[4 * j + 20];
          if ( v42 < 0 )
            break;
          sqlite3VdbeChangeP2(v28, v42, v40);
          v16 = (char *)sqlite3KeyInfoRef(v41);
          sqlite3VdbeChangeP4((int)v28, v42, v16, -9);
          *(_DWORD *)&i[4 * j + 20] = -1;
        }
      }
      sqlite3KeyInfoUnref((int)v41);
    }
    else
    {
      v18 = 7;
    }
  }
LABEL_69:
  *(_DWORD *)(a3 + 12) = v46;
  *(_DWORD *)(a3 + 16) = v47;
  sqlite3SelectDelete((_DWORD *)v26, v19);
  return v18;
}