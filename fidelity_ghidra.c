fprintf(*(FILE **)(lVar1 + 8),"%.*x",(ulong)param_3,param_2);	// I1 Pointer arithmetic to access struct members
(*p_free)(*(undefined8 *)(param_1 + 0x18));	// I1 Pointer arithmetic to access struct members
*(int *)(param_1 + 0x10) = *(int *)(param_1 + 0x10) + 1;	// I1 Pointer arithmetic to access struct members
*(long *)(*param_1 + 0x28) = lVar3 + 0x20;	// I1 Pointer arithmetic to access struct members
*(long *)(lVar3 + 0x20) = *param_1;	// I1 Pointer arithmetic to access struct members
*(long **)(lVar3 + 0x28) = param_1;	// I1 Pointer arithmetic to access struct members
*(ulong *)(param_2 + 0x18) = (ulong)param_1;	// I1 Pointer arithmetic to access struct members
*(undefined *)(param_1 + 0x85) = 1;	// I1 Pointer arithmetic to access struct members
*(undefined *)(param_1 + 0x86) = 0;	// I1 Pointer arithmetic to access struct members
*(undefined4 *)((long)pvVar1 + 0x2001c) = param_1;	// I1 Pointer arithmetic to access struct members
*(undefined4 *)((long)pvVar1 + 0xc) = 0;	// I1 Pointer arithmetic to access struct members
*(undefined4 *)((long)pvVar1 + 8) = 0;	// I1 Pointer arithmetic to access struct members
*(undefined8 *)(*(long *)(param_1 + 0x20) + 0x40) = 0;	// I1 Pointer arithmetic to access struct members
*(undefined8 *)(*(long *)(param_1 + 0x20) + 0x40) = param_2;	// I1 Pointer arithmetic to access struct members
*(undefined8 *)(param_1 + 0x18) = param_2;	// I1 Pointer arithmetic to access struct members
*(undefined8 *)(param_1 + 0x20) = param_2;	// I1 Pointer arithmetic to access struct members
*param_1 = lVar3;	// I1 Pointer arithmetic to access struct members
*param_2 = 0;	// I1 Pointer arithmetic to access struct members
*ppvVar1 = (void *)0x0;	// I1 Pointer arithmetic to access struct members
*ppvVar1 = pvVar2;	// I1 Pointer arithmetic to access struct members
if ((param_2 != (void *)0x0) && (param_1 != 0)) {	// I1 Pointer arithmetic to access struct members
if (*(long *)(lVar3 + 0x20) == 0) {	// I1 Pointer arithmetic to access struct members
if (*(long *)(param_1 + 0x10) != 0) {	// I1 Pointer arithmetic to access struct members
if (*(long *)(param_1 + 0x18) == 0) {	// I1 Pointer arithmetic to access struct members
if (*ppvVar1 == (void *)0x0) {	// I1 Pointer arithmetic to access struct members
if (ppvVar1 == (void **)0x0) {	// I1 Pointer arithmetic to access struct members
lVar1 = *(long *)(in_FS_OFFSET + 0x28);	// I1 Pointer arithmetic to access struct members
p_fclose(*(long *)(param_1 + 0x10));	// I1 Pointer arithmetic to access struct members
param_1[1] = lVar3 + 0x20;	// I1 Pointer arithmetic to access struct members
pcVar3 = (char *)0x0;	// I1 Pointer arithmetic to access struct members
ppvVar1 = (void **)0x0;	// I1 Pointer arithmetic to access struct members
ppvVar1[1] = (void *)0x0;	// I1 Pointer arithmetic to access struct members
ppvVar1[1] = param_2;	// I1 Pointer arithmetic to access struct members
ppvVar1[2] = (void *)0x0;	// I1 Pointer arithmetic to access struct members
puVar1 = (undefined *)list_remove_value(list,test1);	// I1 Pointer arithmetic to access struct members
pvVar2 = (void *)ft_memmove(*ppvVar1,param_1,param_2);	// I1 Pointer arithmetic to access struct members
pvVar2 = malloc((size_t)param_2);	// I1 Pointer arithmetic to access struct members
return (void **)0x0;	// I1 Pointer arithmetic to access struct members
iVar1 = getWindowSize(0x4040e8,0x4040ec);	// I2 String literal as single integer
((int)((ulong)(param_2 >> 4) % (lVar4 - 0x10000U >> 0xe)) + 4) * 0x4000 + lVar3;	// I2 String literal as single integer
if (*pcRam00000000001010e0 == '\x06') {	// I2 String literal as single integer
uVar2 = fz_strlcpy(param_4,&DAT_00100cdf,param_5);	// I2 String literal as single integer
__isoc99_scanf(&DAT_00405864,&local_c);	// I2 String literal as single integer
interpret_rtl_and(&t0,0x101064,&DAT_0010102c);	// I2 String literal as single integer
E._0_4_ = 0;	// I2 String literal as single integer
E._4_4_ = 0;	// I2 String literal as single integer
E._16_4_ = 0;	// I2 String literal as single integer
printf(&DAT_00405fb0);	// I2 String literal as single integer
char *pcVar3;	// I4 Extraneous variable
char cVar1;	// I4 Extraneous variable
char cVar2;	// I4 Extraneous variable
int *piVar2;	// I4 Extraneous variable
int iVar1;	// I4 Extraneous variable
long in_FS_OFFSET;	// I4 Extraneous variable
long lVar1;	// I4 Extraneous variable
long lVar4;	// I4 Extraneous variable
undefined *puVar1;	// I4 Extraneous variable
undefined4 uVar2;	// I4 Extraneous variable
undefined8 uVar1;	// I4 Extraneous variable
undefined8 uVar2;	// I4 Extraneous variable
ushort **ppuVar1;	// I4 Extraneous variable
void *pvVar2;	// I4 Extraneous variable
int iVar1;	// I4 Extraneous variable.
piVar2 = __errno_location();	// I6 Expanded standard symbol
piVar2 = __errno_location();	// I6 Expanded standard symbol
ppvVar1 = (void **)malloc(0x18);	// I6 Expanded standard symbol
pvVar1 = malloc(0x20020);	// I6 Expanded standard symbol
y_FreeUnit(txtsBlock,param_1);	// I6 Expanded standard symbol
cVar1 = CheckBaseObject(param_1,7);	// I6 Expanded user-defined macro
lVar3 = memory_region(0x83);	// I6 Expanded user-defined macro
lVar4 = memory_region_length(0x83);	// I6 Expanded user-defined macro
uVar1 = exitError(param_1,param_2,3,0xffffffd5);	// I6 Expanded user-defined macro
if (((param_2 == 0) || (0x1b5d < param_2)) && ((param_2 < 0x1f41 || (0x1f85 < param_2)))) {	// I6 Expanded user-defined macros
if ((cVar1 == '\x01') && (cVar1 = CheckBaseObject(param_2,6), cVar1 == '\x01')) {	// I6 Expanded user-defined macros
return 0;	// I6 Expanded user-defined macros
TLN_SetLastError(0);	// I6 Expanded user-defined macros
rtl_update_ZFSF(&t0,_DAT_0010105c);	// I6 String literal as single integer
cpunum_set_reset_line(1,0);	// I6 Uses expanded macros
if (cVar2 == '\0') {	// I6 Uses expanded macros
return;	// I5 Return value for void function
__stack_chk_fail_local();	// I6 Expanded standard symbol
FUN_00016ca0(param_1);	// I6 Expanded standard symbol
int in_GS_OFFSET;	// I4 Extraneous variable
int iStack_10;	// I4 Extraneous variable
iStack_10 = *(int *)(in_GS_OFFSET + 0x14);	// I1 Pointer arithmetic to access struct members
if (iStack_10 != *(int *)(in_GS_OFFSET + 0x14)) {	// I3 Confused control flow refactoring
__assert_fail	// I6 Expanded standard symbol
puVar3 = (undefined4 *)__errno_location();	// I6 Expanded standard symbol
iVar1 = fopen(param_1,&UNK_0005e3e5);	// I2 String literal as single integer
puStack_14 = &UNK_0005f01d;	// I2 String literal as single integer
fprintf(_stderr,&UNK_0005e408,param_1,uVar3);	// I2 String literal as single integer
